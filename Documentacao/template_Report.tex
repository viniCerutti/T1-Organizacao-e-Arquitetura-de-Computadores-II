\documentclass[10pt,a4paper]{article}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{hyperref}
\hypersetup{
	colorlinks = true,
	linkcolor = blue,
	urlcolor = blue,
}
\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  
\author{Vinicius Cerutti e Yuri Bittencourt}
\title{Documentação da Implementação de uma Comunicação Serial Periférico-Processador}
\begin{document}
	\maketitle
	\section{Introdução} \label{introducao}
	A implementação teve como base dois projetos desenvolvidos pelos professores da disciplina de Organização e Arquitetura de Computadores II 2017/2 da Faculdade de informática da PUCRS. Onde um destes projetos era a organização de um processador multiciclo com seu \textit{testbeanch} e uma \href{http://www.inf.pucrs.br/calazans/undergrad/orgarqcompII_CC/MatApoio/Files_Serialinterface.zip}{interface de comunicação serial} baseada no padrão RS-232 e também com seu \textit{testbeanch}. Como processador foi utilizado \href{www.inf.pucrs.br/~calazans/undergrad/orgcomp_EC/mips_multi/Files_MIPS_mult_div.zip}{MIPS\_S}, que possui a seguinte documentação \href{http://www.inf.pucrs.br/~calazans/undergrad/orgcomp_EC/mips_multi/Arq_MIPS_Multiciclo_Spec.pdf}{``Processador Multiciclo - MIPS\_S''}.
	
	Para o desenvolvimento da comunicação serial Periférico-Processador foi desenvolvido um hardware (Lógica de cola), um software e um \textit{testbench}, conforme a figura a seguir (Figura \ref{fig:modelagemt1}).
	\begin{figure}[tbph!]
		\centering
		\includegraphics[width=1\linewidth]{modelagemT1}
		\caption{Estrutura geral da organização}
		\label{fig:modelagemt1}
	\end{figure}
	
	\section{Lógica de Cola}
		A lógica de cola realiza o mapeamento dos diversos componentes do ambiente de entrada do periférico em endereços do mapa de Memória do MIPS. Para isto, foi utilizado os seguintes endereços:\\
		
		\noindent\begin{ttfamily}0x1008000 - tx\_data\end{ttfamily}\\
		\begin{ttfamily}0x1008001 - tx\_av\end{ttfamily}\\
		\begin{ttfamily}0x1008002 - rx\_data\end{ttfamily}\\
		\begin{ttfamily}0x1008003 - rx\_start\end{ttfamily}\\
		\begin{ttfamily}0x1008004 - rx\_busy\end{ttfamily}\\
		
		Estes endereços foram escolhidos, pois são endereços que não relacionam aos endereçamentos do \textit{.data} do MIPS ou das instruções do programa. A lógica de Cola possui o formato de uma máquina de estados onde cada estado é uma sequência ou consequência do programa (software). Assim a lógica de cola é apenas uma máquina de estados, onde poderia ser feita também em duas máquinas já que uma recebe e outra envia dados, porém foi escolhida uma máquina de estados apenas por fins mais didáticos e garantir a ordem do programa.\\
		
		\noindent Desta forma para receber um dado da CPU para interface serial a máquina de estados realiza as seguintes etapas(Figura \ref{fig:enviodedadoscpui-interface}):
		
		\begin{enumerate}
		\item Espera no estado inicial da máquina o endereço de \begin{ttfamily}rx\_busy\end{ttfamily} e no modo de leitura, desta forma, a máquina de estados realiza a consulta do fio de rx\_busy (que vem da interface serial) e coloca como data para a CPU.
		\item Se \begin{ttfamily}rx\_busy\end{ttfamily} for igual a 0 então pode-se ir para o próximo estado que é escrita no endereço \begin{ttfamily}rx\_data\end{ttfamily}, caso o \begin{ttfamily}rx\_busy\end{ttfamily} for igual a 1, então a FSM continua no estado inicial.
		\item Com a escrita no endereço de \begin{ttfamily}rx\_data\end{ttfamily} ativa-se, o sinal de \begin{ttfamily}rx\_start\end{ttfamily} e obtêm-se o dado transmitido da CPU para lógica de cola e a máquina de estados vai para o próximo estado.
		\item  Neste estado verifica-se se o dado recebido da CPU foi enviado com sucesso para a interface serial, para isso, necessita que o \begin{ttfamily}rx\_busy\end{ttfamily} esteja em 0, as instruções ficam presas neste estado até que \begin{ttfamily}rx\_busy\end{ttfamily} esteja livre. Estando livre pode-se voltar para o estado inicial da máquina onde pode-se realizar um envido de dado ou recebimento de dado.
		\end{enumerate}
		
		\begin{figure}[tbph!]
			\centering
			\includegraphics[width=0.95\linewidth]{envioDeDadosCPUI-Interface}
			\caption{Exemplo de envio de Dados CPU para interface Serial}
			\label{fig:enviodedadoscpui-interface}
		\end{figure}
		
		
		\noindent Assim para o recebimento de dados, ou seja, interface serial para CPU, a máquina de estados realiza as seguintes etapas (Figura \ref{fig:enviologicadecolacpu}):
	
	\begin{enumerate}
		\item Espera no estado inicial da máquina o endereço de \begin{ttfamily}tx\_av\end{ttfamily} e no modo de leitura, desta forma, a máquina de estados realiza a consulta do \textit{signal} interno de tx\_av e coloca como data para a CPU.
		\item Se o fio interno \begin{ttfamily}tx\_av\end{ttfamily} for igual a 1 então, carregada o dado a ser entregue para a CPU e passa a ir para o próximo estado que é leitura no endereço \begin{ttfamily}tx\_data\end{ttfamily}, caso o \textit{signal} \begin{ttfamily}tx\_av\end{ttfamily} for igual a 0, então a FSM continua no estado inicial.
		\item Com a leitura no endereço de \begin{ttfamily}tx\_data\end{ttfamily} transfere-se o dado do registrador auxiliar para a data do CPU e marca como dado já lido, e retorna para o estado inicial.
	\end{enumerate}

		\begin{figure}[tbph!]
			\centering
			\includegraphics[width=1.0\linewidth]{envioLogicaDeColaCpu}
			\caption{Recebimento de dados da interface Serial para o periférico}
			\label{fig:enviologicadecolacpu}
		\end{figure}
		
		
		Como estrutura auxiliar foi utilizado dois registradores para armazenar as informações de \begin{ttfamily}rx\_data\end{ttfamily} e \begin{ttfamily}tx\_data\end{ttfamily} quando solicitados, pois como o dado da CPU é subscrito a cada instrução estes valores seriam perdidos e assim não sendo possível realizar a envio e recebimento de dados. 
		
		Além disso, o \textit{signal} de tx\_av é ativado em apenas um \textit{clock}, ou seja necessitava guardar este valor até a instrução for uma leitura no \begin{ttfamily} tx\_av \end{ttfamily} e leitura do \begin{ttfamily} tx\_data\end{ttfamily}, para isso foi utilizado um registador que salva em 1 quando tx\_av for um e é desativado quando aquele dado for transmitido para para a CPU, isto é, quando for realizada a leitura de \begin{ttfamily}tx\_data\end{ttfamily}. 
		
		Também foi utilizado uma lógica para desativar o a memória do MIPS enquanto o os endereços eram do periférico, isso não foi obrigatório fazer, porém foi feito assim por motivo de seguranças, outra coisa a se mencionar o \textit{chip enable} (ce) da lógica de cola é o inverso do convencional, ou seja, trabalha com valor 0 no lugar de 1, foi escolhido trabalhar assim, pois a RAM da CPU trabalhava assim também.
		
		\section{Periférico}
		
		Para o periférico foi planejada a ideia de receber dois valores quaisquer e devolver a soma destes valores. Além disso, foi realizado testes de performance para descobrir a melhor velocidade para se utilizar e a escolha foi de se trabalhar com a maior velocidade possível que é 115.200 bits por segundo. Para realizar a sincronização, ou melhor, para a interface serial se adaptar com a velocidade transmissão di periférico é necessário que o periférico mande o valor de 0x55 que equivale (01010101 em binário) na sua velocidade.
		
		Também valores recebidos e enviados do periférico começam com o bit de \textit{start} bit e terminam com o bit de \textit{stop} bit e na ordem binária ao contrária. O periférico funciona também no formato de uma máquina de estado única, além disso, possui o seu próprio \textit{clock} que foi calculado da seguinte maneira:
		
		\[\frac{1s \times 1b}{115200b} = \frac{10^{6}}{115200} = 8.68055 ns = 8.68 us\]
		
		Além disso, uma estrutura auxiliar um \textit{array} foi utilizado para armazenar os 8 bits de cada valor recebido, foi utilizado um \textit{array}, pelo seguinte fator: com \textit{array} é possível saber já quantos dados já foram utilizado e não é necessário declarar novos estados ou \textit{signals} para salvar novos valores, basta incrementar o índice do \textit{array} para receber um proximo número.
		
		Assim como o periférico deseja realizar a soma de apenas dois valores, quando o índice do vetor for igual dois então que dizer que os dois valores já estão prontos para serem somados e enviados para a interface serial. Também foi utilizado contadores de bits para enviar e receber dados, assim obteve-se controle dos bits.
		
		Para o envio do valor de sincronização (0x55) foi criado um estado especial para ele, pois são 11 bits de envio. Já para o recebimento de um bit (para formar um valor numérico) teve que seguir os seguintes passos na máquina de estados (Figura \ref{fig:perifericorecebimento2dados}):
		
		\begin{enumerate}
			\item Se o valor do índice do vetor (que armazena os números para serem somados) for diferente de dois, então contador de bits de recebimento deve ser alterado para 8 e logo em seguida verificar se o dado que esta sendo recebido é o \textit{start} bit, se for então deve ir para próximo estado, senão permanece no estado inicial.
			\item No próximo estado realiza-se o recebimento dos outros bits até o contador de bits for maior do que 1, se o contador do bit for igual a 1 então deve-se salvar este bit e ir para próximo estado que é verificar se o próximo bit é o \textit{stop} bit.
			\item se o próximo bit for o \textit{stop} então o índice do vetor é incrementado e volta-se para o estado inicial.
		\end{enumerate}
		\begin{figure}[tbph!]
			\centering
			\includegraphics[width=1\linewidth]{perifericoRecebimento2Dados}
			\caption{Periférico recebendo dois valores}
			\label{fig:perifericorecebimento2dados}
		\end{figure}
		
		\noindent Para o envio de dados (periférico para interface serial), possui a mesma lógica do recebimento de dados, porém com dois estados a menos, pois não necessita verificar o \textit{start} e \textit{stop} bit já que eles estão inclusos (Figura \ref{label}):
		\begin{enumerate}
			\item No estado inicial se o valor do índices do vetor for igual a dois então significa que já possui dois valores para realizar a soma, assim, neste mesmo estado realiza-se a soma e arruma o \textit{stop} bit. Também como deve ser enviado na ordem invertida o número, o contador de envio começa em zero.
			\item No próximo estado o dado (a soma) é enviado bit a bit até o contador for menor ou igual a 8, quando for igual 9 (que é o ultimo bit), envia-se este ultimo bit e zera o índice do vetor (assim consegue-se dizer que aqueles dados já foram processados) e volta para o estado inicial.
			
		\end{enumerate}
		\begin{figure}[tbph!]
			\centering
			\includegraphics[width=1\linewidth]{envioPeriferico}
			\caption{Envio do dado 0x55 e da soma dos outros valores}
			\label{fig:envioperiferico}
		\end{figure}
		
		\section{Programa}
		Este programa possui a finalidade de realizar a comunicação da CPU com o periférico, desta forma ele realiza o envio e obtenção de dados. As primeiras linhas de código do programa é o tempo aproximado para realizar a sincronização entre o periférico e a interface serial. Para descobrir o valor aproximado do laço foi realizado o seguinte cálculo:
		\[\frac{8680ns \times 1 ciclo}{20ns} = 434 ciclos\]
		onde $8680ns$ é a velocidade do periférico e $20ns$ é a realização de um ciclo do processador. Com isso se obtêm a quantidade de ciclos para o envio de 1 bit apenas, para enviar 10 bits seria necessário 4340 ciclos. Como cada instrução do primeiro loop dura aproximadamente 4 ciclos conforme a documentação do MIPS explicada na introdução (Capitulo \ref{introducao}) o valor final seria 362 vezes necessárias para fazer o loop, porém executando com este valor percebeu-se que necessitaria 108 repetições a mais para concluir o envio do dado 0x55. 
		
		Além disso, para enviar um dado do MIPS para a lógica de cola necessita esperar o sinal \begin{ttfamily}rx\_busy\end{ttfamily} estar em 0 ou seja a interface serial esta desocupada, para isso necessita realizar um laço verificando o endereço de \begin{ttfamily}rx\_busy\end{ttfamily} até for 0. Depois disso é possível salvar o \begin{ttfamily}rx\_data\end{ttfamily}, com uma comando de salvar. 
		
		Para ler o dado do periférico no processador através do programa, é da mesma maneira necessita, criar um laço com o valor de \begin{ttfamily}tx\_av\end{ttfamily} se este valor for igual a 1 então o periférico possui um dado. Assim o processador (programa) pode realizar uma leitura no endereço de \begin{ttfamily}tx\_data\end{ttfamily}.
		
\end{document}